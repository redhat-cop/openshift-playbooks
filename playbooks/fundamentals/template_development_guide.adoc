---
---
= OpenShift Templates Development Guide
Eric Sauer <esauer@redhat.com>
:toc: macro
:toc-title:

This doc provides some guidance, tips, and best practices for using, developing and managing templates in OpenShift.

toc::[]

== Overview

link:https://docs.openshift.com/container-platform/3.7/dev_guide/templates.html[OpenShift Templates] are best known as the way in which the OpenShift Web Console is populated with quickstart applications and other content. However, they are also a very powerful tool that, used thoughtfully, can be the building block of an _Infrastructure as Code_ solution for managing many aspects of cluster and application state.

In this guide, we dive deep into the usage and makeup of OpenShift templates, covering first how they can be used, then how to write custom templates, and finally, how to put all of this knowledge together to create powerful automation workflows for managing workloads in OpenShift.

== OpenShift Template Discovery

We're going to start by doing an interactive, exploratory deep into templates, starting with the basics and working our way deeper.

=== Kickin' it off with some oc new-app

In order to get kicked off in template exploration, let's start by spinning up a Java application using `oc new-app`.

```
$ oc new-app --template=openjdk18-web-basic-s2i
--> Deploying template "openshift/openjdk18-web-basic-s2i" to project eric-test

     Red Hat OpenJDK 8
     ---------
     Application template for Java applications built using S2I.

     A new java application has been created in your project.

     * With parameters:
        * Application Name=openjdk-app
        * Custom http Route Hostname=
        * Git Repository URL=https://github.com/jboss-openshift/openshift-quickstarts
        * Git Reference=master
        * Context Directory=undertow-servlet
        * Github Webhook Secret=4sPr4Br3 # generated
        * Generic Webhook Secret=V218WEHy # generated
        * ImageStream Namespace=openshift

--> Creating resources ...
    service "openjdk-app" created
    route "openjdk-app" created
    imagestream "openjdk-app" created
    buildconfig "openjdk-app" created
    deploymentconfig "openjdk-app" created
--> Success
    Build scheduled, use 'oc logs -f bc/openjdk-app' to track its progress.
    Run 'oc status' to view your app.
```

Looking at what was done here, we used an `oc` command to instantiate a template by name. The template we used (`openjdk18-web-basic-s2i`) is a template that has been preloaded into OpenShift for convenience. We can also see that several objects were created as a result, including a `Service`, `Route`, `ImageStream`, `BuildConfig` and a `DeploymentConfig`. We can take a look at these templates using some oc commands.

```
$ oc get templates -n openshift
NAME                                            DESCRIPTION                                                                        PARAMETERS        OBJECTS
...
openjdk18-web-basic-s2i                         Application template for Java applications built using S2I.                        8 (1 blank)       5
...
```

If we want to get a few more details, we can use oc `describe` instead:

```
$ oc describe template openjdk18-web-basic-s2i -n openshift
Name:		openjdk18-web-basic-s2i
Namespace:	openshift
Created:	2 weeks ago
Labels:		<none>
Description:	Application template for Java applications built using S2I.
Annotations:	iconClass=icon-jboss
		openshift.io/display-name=Red Hat OpenJDK 8
		tags=java,xpaas
		version=1.1.0

Parameters:
    Name:		APPLICATION_NAME
    Display Name:	Application Name
    Description:	The name for the application.
    Required:		true
    Value:		openjdk-app

    Name:		HOSTNAME_HTTP
    Display Name:	Custom http Route Hostname
    Description:	Custom hostname for http service route.  Leave blank for default hostname, e.g.: <application-name>-<project>.<default-domain-suffix>
    Required:		false
    Value:		<none>

    Name:		SOURCE_REPOSITORY_URL
    Display Name:	Git Repository URL
    Description:	Git source URI for application
    Required:		true
    Value:		https://github.com/jboss-openshift/openshift-quickstarts

    Name:		SOURCE_REPOSITORY_REF
    Display Name:	Git Reference
    Description:	Git branch/tag reference
    Required:		false
    Value:		master

    Name:		CONTEXT_DIR
    Display Name:	Context Directory
    Description:	Path within Git project to build; empty for root project directory.
    Required:		false
    Value:		undertow-servlet

    Name:		GITHUB_WEBHOOK_SECRET
    Display Name:	Github Webhook Secret
    Description:	GitHub trigger secret
    Required:		true
    Generated:		expression
    From:		[a-zA-Z0-9]{8}

    Name:		GENERIC_WEBHOOK_SECRET
    Display Name:	Generic Webhook Secret
    Description:	Generic build trigger secret
    Required:		true
    Generated:		expression
    From:		[a-zA-Z0-9]{8}

    Name:		IMAGE_STREAM_NAMESPACE
    Display Name:	ImageStream Namespace
    Description:	Namespace in which the ImageStreams for Red Hat Middleware images are installed. These ImageStreams are normally installed in the openshift namespace. You should only need to modify this if you've installed the ImageStreams in a different namespace/project.
    Required:		true
    Value:		openshift


Object Labels:	template=openjdk18-web-basic-s2i,xpaas=1.4.0

Message:	A new java application has been created in your project.

Objects:
    Service		${APPLICATION_NAME}
    Route		${APPLICATION_NAME}
    ImageStream		${APPLICATION_NAME}
    BuildConfig		${APPLICATION_NAME}
    DeploymentConfig	${APPLICATION_NAME}
```

Here, we can see that there are parameters available that we can pass to the template to customize the object we want to create. Let's try to use a few of these to make our sample application more relevant to us.

```
oc new-app --template=openjdk18-web-basic-s2i -p APPLICATION_NAME=spring-rest -p SOURCE_REPOSITORY_URL=https://github.com/redhat-cop/spring-rest.git -p CONTEXT_DIR=''
```

If we look at what's created in our project, we can see that we now have two of everything. Since we passed a new value for `APPLICATION_NAME`, and the template sets all objects to use `${APPLICATION_NAME}` in the `name:` field, the `new-app` command resulted in all new objects created with new names.

```
$ oc get all
NAME             TYPE      FROM         LATEST
bc/openjdk-app   Source    Git@master   1
bc/spring-rest   Source    Git@master   1

NAME                   TYPE      FROM          STATUS     STARTED       DURATION
builds/openjdk-app-1   Source    Git@08c923a   Complete   3 weeks ago   30s
builds/spring-rest-1   Source    Git@978d4b0   Complete   3 weeks ago   1m7s

NAME             DOCKER REPO                                              TAGS      UPDATED
is/openjdk-app   docker-registry.default.svc:5000/eric-test/openjdk-app   latest    3 weeks ago
is/spring-rest   docker-registry.default.svc:5000/eric-test/spring-rest   latest    3 weeks ago

NAME             REVISION   DESIRED   CURRENT   TRIGGERED BY
dc/openjdk-app   1          1         1         config,image(openjdk-app:latest)
dc/spring-rest   1          1         1         config,image(spring-rest:latest)

NAME               DESIRED   CURRENT   READY     AGE
rc/openjdk-app-1   1         1         1         21d
rc/spring-rest-1   1         1         1         20d

NAME                 HOST/PORT                                         PATH      SERVICES      PORT      TERMINATION   WILDCARD
routes/openjdk-app   openjdk-app-eric-test.apps.d1.casl.rht-labs.com             openjdk-app   <all>                   None
routes/spring-rest   spring-rest-eric-test.apps.d1.casl.rht-labs.com             spring-rest   <all>                   None

NAME              CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/openjdk-app   172.30.125.201   <none>        8080/TCP   21d
svc/spring-rest   172.30.61.234    <none>        8080/TCP   20d

NAME                     READY     STATUS      RESTARTS   AGE
po/openjdk-app-1-build   0/1       Completed   0          21d
po/openjdk-app-1-gwtj9   1/1       Running     0          21d
po/spring-rest-1-build   0/1       Completed   0          20d
po/spring-rest-1-xtbx2   1/1       Running     0          20d
```

Let's go ahead and clean up the old `openjdk-app` resources. Because the template we used to create the objects made good use of labels in its `objects` list, we can do this very easily.

```
$ oc delete all -l application=openjdk-app
buildconfig "openjdk-app" deleted
imagestream "openjdk-app" deleted
deploymentconfig "openjdk-app" deleted
route "openjdk-app" deleted
service "openjdk-app" deleted
pod "openjdk-app-1-gwtj9" deleted
```

So far, we've learned that...

- a _Template_ is a collection of resource definitions that can be parameterized
- `oc new-app` is a very simple and easy way to quickly instantiate a template
- templates can be loaded into OpenShift and then referenced by name

This is a great start, but it does leave some further questions that might be worth exploring:

- How else could I work with templates?
- What about templates that aren't pre-loaded into OpenShift?
- How might I update resources that were created from a template?

Let's move on to the next phase in our exploration

=== Template files, processing, applying

=== What we've learned and where to go from here

== Building Custom Templates

Custom templates allow a user to truly unlock the power of OpenShift in many ways. This section will dive into various approaches to building custom templates. But first, let's dive into the basic structure and makeup of a template.

=== Template Structure

The basic top level structure of an OpenShift template is as follows:

```
apiVersion: v1
kind: Template
labels:
message: <Creation message>
metadata:
  name: <template name>
objects:
parameters:
```

The important sections here are:

- `kind: Template` - defines the object as a template
- `message` - An optional message to return to the user when the template is created using the Web Console
- `metadata` - Standard metadata section for all Kubernetes objects, including object `name`.
- `objects` - Yaml list of Object definitions to be included in the template. (same format as `<kind: List>.items`)
- `parameters` - Optional list of parameters with which to do substitution within the `objects` list.

Let's look at an example, using the OpenJDK template we were experimenting with above. We can use `oc export` to get a clean copy of the template code.

```
$ oc export template/openjdk18-web-basic-s2i -n openshift
apiVersion: v1
kind: Template
labels:
  template: openjdk18-web-basic-s2i
  xpaas: 1.4.0
message: A new java application has been created in your project.
metadata:
  annotations:
    description: Application template for Java applications built using S2I.
    iconClass: icon-jboss
    openshift.io/display-name: Red Hat OpenJDK 8
    tags: java,xpaas
    version: 1.1.0
  name: openjdk18-web-basic-s2i
objects:
- kind: Service
  metadata:
    labels:
      application: ${APPLICATION_NAME}
    name: ${APPLICATION_NAME}
...
- kind: Route
  metadata:
    labels:
      application: ${APPLICATION_NAME}
    name: ${APPLICATION_NAME}
...
- kind: ImageStream
  metadata:
    labels:
      application: ${APPLICATION_NAME}
    name: ${APPLICATION_NAME}
...
- kind: BuildConfig
  metadata:
    labels:
      application: ${APPLICATION_NAME}
    name: ${APPLICATION_NAME}
...
- kind: DeploymentConfig
  metadata:
    labels:
      application: ${APPLICATION_NAME}
    name: ${APPLICATION_NAME}
...
parameters:
- description: The name for the application.
  displayName: Application Name
  name: APPLICATION_NAME
  required: true
  value: openjdk-app
...
```

=== Methods for Writing or Generating Templates

==== Start from an existing template

Exporting and modifying an existing template is many times the fastest path to success. Simply peruse through the set of templates provided out of the box by OpenShift, find the one closest to what you need, and export it.

```
$ oc get templates -n openshift
...
s2i-spring-boot-camel-config                    Spring Boot and Camel using ConfigMaps and Secrets. This quickstart demonstra...   13 (2 blank)      3
...

$ oc export template/s2i-spring-boot-camel-config -n openshift > my-new-spring-template.yml
```

Once exported the first thing to do is make sure to rename it. Just make sure and be thorough, a templates name is generally used multiple times in the template.

```
$ grep 's2i-spring-boot-camel-config\|my-new-spring-template' ./my-new-spring-template.yml
  template: s2i-spring-boot-camel-config
  name: s2i-spring-boot-camel-config
  value: s2i-spring-boot-camel-config

$ sed -i 's/s2i-spring-boot-camel-config/my-new-spring-template/g' ./my-new-spring-template.yml

$ grep 's2i-spring-boot-camel-config\|my-new-spring-template' ./my-new-spring-template.yml
  template: my-new-spring-template
  name: my-new-spring-template
  value: my-new-spring-template
```

From here, you're free to modify whatever needs modifying to meet your needs. When modifying an existing template, be aware that there is a lot of metadata in the form of labels and annotations that may or may not be relevant to your new template. The good news is that, if you are writing a template for automation purposes, and not for use in the Web Console, much of that stuff can be cleaned out, as it is mostly used to populate parts of the UI and little else. Just keep in mind that you may want to spend the time updating those values if you plan to create new Web Console quickstarts.

==== Build from Scratch

A more barebones approach is to simply write the template from scratch. This is especially nice when you need a very minimal template, and you want to keep it clean of any leftover metadata from the original template. Just start with this skeleton and you'll be good to go.

```
apiVersion: v1
kind: Template
labels:
message: <Creation message>
metadata:
  name: <template name>
objects:
parameters:
```

==== Export existing objects as a Template

Maybe the most powerful mode of creating a new template is to use `oc export` to generate one from a set of already created objects. This allows you to first build and wire up and application manually using the client tools and/or the Web Console, and then capture your work in the form of a repeatable template.

=== Best Practices for Template Writing

The following is a list of suggested best practices for template writing.

- **Include a `template` label in all objects.**
+
Including a common label across all objects created from a template allows users and admins to track objects created from a particular template as a group.
+
- **Include an `app` label in all objects.**
+
In addition to a template label, which will have a static value, including an `app=${APPLICATION_NAME}` label provides a dynamic label that can be used to query a specific instance of a template.
+
- **Keep Templates confined to a scope**
+
When building a new template, it's good to keep both the user and the use case in mind. For example, if I created a template that defines an application, but also defined a `ClusterRole` and `ClusterRoleBinding`, then that template would require a `cluster-admin`, or someone with elevated privileges in order to instantiate it. This makes it less useful to regular developers. A better design would be to create one template for the local application components and a separate one for the cluster-level objects.
+
- **Separate Build templates from Deploy templates.**
+
Similarly to the previous point. It's important to consider _when_ a template would be instantiated. A common example is a template defining `BuildConfigs` and `Deployments`/`Services`/etc. Typically, an app only builds in a single project (representing a _development_ environment), but may get deployed to multiple projects (_dev_, _uat_, _production_). For this reason, its helpful to have one template that defines all of your build components, and a separate template that defines the deployment related componentns. A good example of this can be seen in our link:https://github.com/redhat-cop/container-pipelines/tree/master/basic-spring-boot#openshift-templates[Container Pipelines Quickstarts].

== Templates & Infrastructure as Code (IaC)

=== Use oc apply for repeatable process

This presentation from KubeCon 2017 provides more interesting deep dives into using oc apply.

video::CW3ZuQy_YZw[youtube]

=== Automation using templates & Ansible

=== Developing Template-based workflows
